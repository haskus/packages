== System Internals <system-internals>

=== Device management <device-management>

Internally `haskus-system` mounts a `sysfs` virtual file system through
which the Linux kernel exposes the hardware of the machine. In this file-system
each device is exposed as a sub-directory in the `/devices` directory and the
path to the device's directory uniquely identifies the device in the system.

Directory nesting represents the device hierarchy as the system sees it.
Regular files in device directories represent device properties that can be
read and sometimes written into from user-space.  Sometimes, when the tree
relationship between devices is not sufficient, relations between devices are
represented as symbolic links.

==== File descriptor vs Handle

Linux allows programs in user-space to have handles on kernel objects.
Suppose the kernel has an object `A` and a reference `R_A` on `A`.  Instead of
directly giving `R_A` to user-space processes, the kernel maintains a
per-process array of kernel object references: `D_pid` for the process with
the `pid` identifier.  To "give" `R_A` to this process, the kernel finds
an empty cell in `D_pid`, put `R_A` in it and gives the index of the cell to
the process.

For historical reasons, the cell index is called a file descriptor and `D_pid`
a file descriptor table even if in Linux they can be used for kernel objects
that are not files (e.g., clocks, memory). User-space processes can only refer
to kernel objects through theses indirect references. Note that the file
descriptor table is specific to each process: sharing a file descriptor with
another process does not allow to share the referred kernel object.

In `haskus-system` we use the term "handle" instead of "file descriptor" as we
find it less misleading.

==== Device special files and /dev

Ideally there would be a system call to get a handle on a device by providing
its unique identifier (similarly to the `getDeviceHandleByName` API provided by
`haskus-system`). Sadly it's not the case. We have to:

1. Get the unique device triple identifier from its name

   Linux has two ways to uniquely identify devices:

   - a path in `/devices` in the `sysfs` file-system
   - a triple: a major number, a minor number and a device type (`character` or
     `block`).

   `haskus-system` retrieves the triple by reading different files the the
   `sysfs` device directory.

2. Create and open a device special file

   With a device triple we can create a special file (using the `mknod` system
   call).

   `haskus-system` creates the device special file in a virtual file system
   (`tmpfs`), then opens it and finally deletes it.

Usual Linux distributions use a virtual file-system mounted in `/dev` and
create device special files in it. They let some applications directly access
device special files in `/dev` (e.g., X11). Access control is ensured by file
permissions (user, user groups, etc.). We don't want to do this in
`haskus-system`: we provide high-level APIs instead.


==== Netlink socket

Linux dynamically adds and removes files and directories in the `sysfs`
file-system, when devices are plugged or unplugged. To signal it to user-space,
it sends kernel events in a Netlink socket. The Netlink socket is also used to
pass some other messages, for instance when the kernel wants to ask something to
the user-space. `haskus-system` handles a Netlink socket, parses received
kernel events and delivers them through a STM broadcast channel.

In usual Linux distributions, a daemon called `udev` is responsible of
handling these kernel events. Rules can be written to react to specific events.
In particular, `udev` is responsible of creating device special file in the
`/dev` directory. The naming of theses special files is a big deal for these
distributions as applications use them directly afterwards and don't use the
other unique device identifiers (i.e., the device path in the `sysfs`
file-system).  In `haskus-system`, high-level APIs are provided to avoid
direct references to device special files.


==== Miscellaneous

In usual Linux distributions, `udev` (`man 7 udev`) is responsible of
handling devices. It reads `sysfs` and listens to kernel events to create and
remove device nodes in the `/dev` directory, following customizable rules.  It
can also execute custom commands (`crda`, etc.) to respond to kernel requests.


=== Graphics

==== "Software" rendering (i.e. on the CPU)

For now in this manual we present a simple approach to display rendering:
basically the picture to display is generated by the CPU in host memory and then
transferred to the GPU memory (implicitly by using memory mapping). Most recent
graphic cards propose more efficient approaches: the picture to display is
generated and transformed directly by the graphic card. Instead of sending a
picture, the host sends commands or programs to be executed by the GPU.

Currently Linux doesn't propose a unified interface to advanced graphic card
capabilities from different vendors (these are usually handled by MESA in
user-space and accessed through the OpenGL interface). `haskus-system` doesn't
provide support for them yet.

==== Proprietary drivers

`haskus-system` uses the Kernel Mode Setting (KMS) and the Direct
Rendering Manager (DRM) interfaces. In usual Linux distributions, some graphic
card manufacturers provide closed-source proprietary drivers that do not support
theses interfaces: they use a kernel module and user-space libraries that
communicate together by using a private protocol. The user-space libraries
provide implementations of standard high-level interfaces such as OpenGL and can
be used by rendering managers such as X.org. `haskus-system` doesn't offer a
way to use these drivers.

==== Further reading

The two main acronyms for Linux's display model are KMS (standing for "kernel
mode-setting") and DRM (standing for "direct rendering manager").

As explained in the @device-management, device drivers can support
the `ioctl` system call to handle device specific commands from the
user-space. The display interface is almost entirely based on it. Additionally,
`mmap` is used to map graphic card memory in user-space and `read` is used
to read events (V-Blank and page-flip asynchronous completion).

In usual Linux distributions, the `libdrm` library provides an interface over
these system calls. You can learn about the low-level interface by reading the
`drm` manual (`man drm`, `man drm-kms`, etc.) or its source code at
https://cgit.freedesktop.org/mesa/drm/.

David Herrmann has written
#link("https://dvdhrm.wordpress.com/?s=drm-mode-setting")[a good tutorial]
explaining how to use the legacy low-level display interface in the form of C
source files with detailed comments. While some details of the interface have
changed since he wrote it (e.g., the way to flip frame buffers and the atomic
interface), it is still a valuable source of information.

The newer atomic interface is described in an article series on LWN called
"Atomic mode setting design overview" (August 2015) by Daniel Vetter:
- https://lwn.net/Articles/653071/
- https://lwn.net/Articles/653466/

Wayland is the new display system for usual
Linux based distributions. It can be a great source of inspiration and of
information:
- http://wayland.freedesktop.org

You can also read the Linux kernel code located in `drivers/gpu/drm` in the
kernel sources.

Multi-GPU is supported by Linux. In particular:

- Buffer sharing is supported with
#link("https://01.org/linuxgraphics/gfx-docs/drm/drm-memory-management.html\#drm-prime-support")[DRM
Prime]
- GPU switching is supported with #link("https://01.org/linuxgraphics/gfx-docs/drm/vga_switcheroo.html")[vga_switcheroo]

https://www.elinux.org/images/4/45/Atomic_kms_driver_pinchart.pdf

KMS/DRM history:

- https://libv.livejournal.com/13443.html
- https://ppaalanen.blogspot.com/2014/06/from-pre-history-to-beyond-global.html
- https://lwn.net/Articles/653071 and https://lwn.net/Articles/653466/


